// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.27.1
// source: grpc.proto

package main

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Atlas_Ping_FullMethodName              = "/main.Atlas/Ping"
	Atlas_UploadInvoice_FullMethodName     = "/main.Atlas/UploadInvoice"
	Atlas_RunScrub_FullMethodName          = "/main.Atlas/RunScrub"
	Atlas_RunQueue_FullMethodName          = "/main.Atlas/RunQueue"
	Atlas_GetScrub_FullMethodName          = "/main.Atlas/GetScrub"
	Atlas_GetScrubMetrics_FullMethodName   = "/main.Atlas/GetScrubMetrics"
	Atlas_GetScrubRebates_FullMethodName   = "/main.Atlas/GetScrubRebates"
	Atlas_GetScrubFile_FullMethodName      = "/main.Atlas/GetScrubFile"
	Atlas_GetInvoice_FullMethodName        = "/main.Atlas/GetInvoice"
	Atlas_GetInvoiceRebates_FullMethodName = "/main.Atlas/GetInvoiceRebates"
	Atlas_UploadTest_FullMethodName        = "/main.Atlas/UploadTest"
)

// AtlasClient is the client API for Atlas service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AtlasClient interface {
	Ping(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Res, error)
	UploadInvoice(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[Rebate, Res], error)
	RunScrub(ctx context.Context, in *InvoiceIdent, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Metrics], error)
	RunQueue(ctx context.Context, in *InvoiceIdent, opts ...grpc.CallOption) (*ScrubRes, error)
	GetScrub(ctx context.Context, in *ScrubIdent, opts ...grpc.CallOption) (*Scrub, error)
	GetScrubMetrics(ctx context.Context, in *ScrubIdent, opts ...grpc.CallOption) (*Metrics, error)
	GetScrubRebates(ctx context.Context, in *ScrubIdent, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ScrubRebate], error)
	GetScrubFile(ctx context.Context, in *ScrubIdent, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ScrubRow], error)
	GetInvoice(ctx context.Context, in *InvoiceIdent, opts ...grpc.CallOption) (*Invoice, error)
	GetInvoiceRebates(ctx context.Context, in *InvoiceIdent, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Rebate], error)
	UploadTest(ctx context.Context, in *TestData, opts ...grpc.CallOption) (*Res, error)
}

type atlasClient struct {
	cc grpc.ClientConnInterface
}

func NewAtlasClient(cc grpc.ClientConnInterface) AtlasClient {
	return &atlasClient{cc}
}

func (c *atlasClient) Ping(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Res, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Res)
	err := c.cc.Invoke(ctx, Atlas_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *atlasClient) UploadInvoice(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[Rebate, Res], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Atlas_ServiceDesc.Streams[0], Atlas_UploadInvoice_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Rebate, Res]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Atlas_UploadInvoiceClient = grpc.ClientStreamingClient[Rebate, Res]

func (c *atlasClient) RunScrub(ctx context.Context, in *InvoiceIdent, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Metrics], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Atlas_ServiceDesc.Streams[1], Atlas_RunScrub_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InvoiceIdent, Metrics]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Atlas_RunScrubClient = grpc.ServerStreamingClient[Metrics]

func (c *atlasClient) RunQueue(ctx context.Context, in *InvoiceIdent, opts ...grpc.CallOption) (*ScrubRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScrubRes)
	err := c.cc.Invoke(ctx, Atlas_RunQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *atlasClient) GetScrub(ctx context.Context, in *ScrubIdent, opts ...grpc.CallOption) (*Scrub, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Scrub)
	err := c.cc.Invoke(ctx, Atlas_GetScrub_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *atlasClient) GetScrubMetrics(ctx context.Context, in *ScrubIdent, opts ...grpc.CallOption) (*Metrics, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Metrics)
	err := c.cc.Invoke(ctx, Atlas_GetScrubMetrics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *atlasClient) GetScrubRebates(ctx context.Context, in *ScrubIdent, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ScrubRebate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Atlas_ServiceDesc.Streams[2], Atlas_GetScrubRebates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ScrubIdent, ScrubRebate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Atlas_GetScrubRebatesClient = grpc.ServerStreamingClient[ScrubRebate]

func (c *atlasClient) GetScrubFile(ctx context.Context, in *ScrubIdent, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ScrubRow], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Atlas_ServiceDesc.Streams[3], Atlas_GetScrubFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ScrubIdent, ScrubRow]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Atlas_GetScrubFileClient = grpc.ServerStreamingClient[ScrubRow]

func (c *atlasClient) GetInvoice(ctx context.Context, in *InvoiceIdent, opts ...grpc.CallOption) (*Invoice, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Invoice)
	err := c.cc.Invoke(ctx, Atlas_GetInvoice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *atlasClient) GetInvoiceRebates(ctx context.Context, in *InvoiceIdent, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Rebate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Atlas_ServiceDesc.Streams[4], Atlas_GetInvoiceRebates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[InvoiceIdent, Rebate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Atlas_GetInvoiceRebatesClient = grpc.ServerStreamingClient[Rebate]

func (c *atlasClient) UploadTest(ctx context.Context, in *TestData, opts ...grpc.CallOption) (*Res, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Res)
	err := c.cc.Invoke(ctx, Atlas_UploadTest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AtlasServer is the server API for Atlas service.
// All implementations must embed UnimplementedAtlasServer
// for forward compatibility.
type AtlasServer interface {
	Ping(context.Context, *Req) (*Res, error)
	UploadInvoice(grpc.ClientStreamingServer[Rebate, Res]) error
	RunScrub(*InvoiceIdent, grpc.ServerStreamingServer[Metrics]) error
	RunQueue(context.Context, *InvoiceIdent) (*ScrubRes, error)
	GetScrub(context.Context, *ScrubIdent) (*Scrub, error)
	GetScrubMetrics(context.Context, *ScrubIdent) (*Metrics, error)
	GetScrubRebates(*ScrubIdent, grpc.ServerStreamingServer[ScrubRebate]) error
	GetScrubFile(*ScrubIdent, grpc.ServerStreamingServer[ScrubRow]) error
	GetInvoice(context.Context, *InvoiceIdent) (*Invoice, error)
	GetInvoiceRebates(*InvoiceIdent, grpc.ServerStreamingServer[Rebate]) error
	UploadTest(context.Context, *TestData) (*Res, error)
	mustEmbedUnimplementedAtlasServer()
}

// UnimplementedAtlasServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAtlasServer struct{}

func (UnimplementedAtlasServer) Ping(context.Context, *Req) (*Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedAtlasServer) UploadInvoice(grpc.ClientStreamingServer[Rebate, Res]) error {
	return status.Errorf(codes.Unimplemented, "method UploadInvoice not implemented")
}
func (UnimplementedAtlasServer) RunScrub(*InvoiceIdent, grpc.ServerStreamingServer[Metrics]) error {
	return status.Errorf(codes.Unimplemented, "method RunScrub not implemented")
}
func (UnimplementedAtlasServer) RunQueue(context.Context, *InvoiceIdent) (*ScrubRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunQueue not implemented")
}
func (UnimplementedAtlasServer) GetScrub(context.Context, *ScrubIdent) (*Scrub, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScrub not implemented")
}
func (UnimplementedAtlasServer) GetScrubMetrics(context.Context, *ScrubIdent) (*Metrics, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScrubMetrics not implemented")
}
func (UnimplementedAtlasServer) GetScrubRebates(*ScrubIdent, grpc.ServerStreamingServer[ScrubRebate]) error {
	return status.Errorf(codes.Unimplemented, "method GetScrubRebates not implemented")
}
func (UnimplementedAtlasServer) GetScrubFile(*ScrubIdent, grpc.ServerStreamingServer[ScrubRow]) error {
	return status.Errorf(codes.Unimplemented, "method GetScrubFile not implemented")
}
func (UnimplementedAtlasServer) GetInvoice(context.Context, *InvoiceIdent) (*Invoice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInvoice not implemented")
}
func (UnimplementedAtlasServer) GetInvoiceRebates(*InvoiceIdent, grpc.ServerStreamingServer[Rebate]) error {
	return status.Errorf(codes.Unimplemented, "method GetInvoiceRebates not implemented")
}
func (UnimplementedAtlasServer) UploadTest(context.Context, *TestData) (*Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadTest not implemented")
}
func (UnimplementedAtlasServer) mustEmbedUnimplementedAtlasServer() {}
func (UnimplementedAtlasServer) testEmbeddedByValue()               {}

// UnsafeAtlasServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AtlasServer will
// result in compilation errors.
type UnsafeAtlasServer interface {
	mustEmbedUnimplementedAtlasServer()
}

func RegisterAtlasServer(s grpc.ServiceRegistrar, srv AtlasServer) {
	// If the following call pancis, it indicates UnimplementedAtlasServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Atlas_ServiceDesc, srv)
}

func _Atlas_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AtlasServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Atlas_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AtlasServer).Ping(ctx, req.(*Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _Atlas_UploadInvoice_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AtlasServer).UploadInvoice(&grpc.GenericServerStream[Rebate, Res]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Atlas_UploadInvoiceServer = grpc.ClientStreamingServer[Rebate, Res]

func _Atlas_RunScrub_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InvoiceIdent)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AtlasServer).RunScrub(m, &grpc.GenericServerStream[InvoiceIdent, Metrics]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Atlas_RunScrubServer = grpc.ServerStreamingServer[Metrics]

func _Atlas_RunQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvoiceIdent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AtlasServer).RunQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Atlas_RunQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AtlasServer).RunQueue(ctx, req.(*InvoiceIdent))
	}
	return interceptor(ctx, in, info, handler)
}

func _Atlas_GetScrub_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScrubIdent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AtlasServer).GetScrub(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Atlas_GetScrub_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AtlasServer).GetScrub(ctx, req.(*ScrubIdent))
	}
	return interceptor(ctx, in, info, handler)
}

func _Atlas_GetScrubMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScrubIdent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AtlasServer).GetScrubMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Atlas_GetScrubMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AtlasServer).GetScrubMetrics(ctx, req.(*ScrubIdent))
	}
	return interceptor(ctx, in, info, handler)
}

func _Atlas_GetScrubRebates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ScrubIdent)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AtlasServer).GetScrubRebates(m, &grpc.GenericServerStream[ScrubIdent, ScrubRebate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Atlas_GetScrubRebatesServer = grpc.ServerStreamingServer[ScrubRebate]

func _Atlas_GetScrubFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ScrubIdent)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AtlasServer).GetScrubFile(m, &grpc.GenericServerStream[ScrubIdent, ScrubRow]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Atlas_GetScrubFileServer = grpc.ServerStreamingServer[ScrubRow]

func _Atlas_GetInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvoiceIdent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AtlasServer).GetInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Atlas_GetInvoice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AtlasServer).GetInvoice(ctx, req.(*InvoiceIdent))
	}
	return interceptor(ctx, in, info, handler)
}

func _Atlas_GetInvoiceRebates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InvoiceIdent)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AtlasServer).GetInvoiceRebates(m, &grpc.GenericServerStream[InvoiceIdent, Rebate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Atlas_GetInvoiceRebatesServer = grpc.ServerStreamingServer[Rebate]

func _Atlas_UploadTest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AtlasServer).UploadTest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Atlas_UploadTest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AtlasServer).UploadTest(ctx, req.(*TestData))
	}
	return interceptor(ctx, in, info, handler)
}

// Atlas_ServiceDesc is the grpc.ServiceDesc for Atlas service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Atlas_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "main.Atlas",
	HandlerType: (*AtlasServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Atlas_Ping_Handler,
		},
		{
			MethodName: "RunQueue",
			Handler:    _Atlas_RunQueue_Handler,
		},
		{
			MethodName: "GetScrub",
			Handler:    _Atlas_GetScrub_Handler,
		},
		{
			MethodName: "GetScrubMetrics",
			Handler:    _Atlas_GetScrubMetrics_Handler,
		},
		{
			MethodName: "GetInvoice",
			Handler:    _Atlas_GetInvoice_Handler,
		},
		{
			MethodName: "UploadTest",
			Handler:    _Atlas_UploadTest_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadInvoice",
			Handler:       _Atlas_UploadInvoice_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "RunScrub",
			Handler:       _Atlas_RunScrub_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetScrubRebates",
			Handler:       _Atlas_GetScrubRebates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetScrubFile",
			Handler:       _Atlas_GetScrubFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetInvoiceRebates",
			Handler:       _Atlas_GetInvoiceRebates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "grpc.proto",
}

const (
	Titan_Ping_FullMethodName                 = "/main.Titan/Ping"
	Titan_GetClaims_FullMethodName            = "/main.Titan/GetClaims"
	Titan_GetSPIs_FullMethodName              = "/main.Titan/GetSPIs"
	Titan_GetNDCs_FullMethodName              = "/main.Titan/GetNDCs"
	Titan_GetEntities_FullMethodName          = "/main.Titan/GetEntities"
	Titan_GetPharmacies_FullMethodName        = "/main.Titan/GetPharmacies"
	Titan_GetESP1Pharms_FullMethodName        = "/main.Titan/GetESP1Pharms"
	Titan_GetEligibilityLedger_FullMethodName = "/main.Titan/GetEligibilityLedger"
	Titan_GetAuths_FullMethodName             = "/main.Titan/GetAuths"
	Titan_GetDesignations_FullMethodName      = "/main.Titan/GetDesignations"
	Titan_GetLDNs_FullMethodName              = "/main.Titan/GetLDNs"
	Titan_SyncCommands_FullMethodName         = "/main.Titan/SyncCommands"
	Titan_SyncScrubs_FullMethodName           = "/main.Titan/SyncScrubs"
	Titan_SyncMetrics_FullMethodName          = "/main.Titan/SyncMetrics"
	Titan_SyncScrubRebates_FullMethodName     = "/main.Titan/SyncScrubRebates"
	Titan_SyncScrubClaims_FullMethodName      = "/main.Titan/SyncScrubClaims"
	Titan_SyncScrubMatches_FullMethodName     = "/main.Titan/SyncScrubMatches"
	Titan_SyncScrubAttempts_FullMethodName    = "/main.Titan/SyncScrubAttempts"
)

// TitanClient is the client API for Titan service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TitanClient interface {
	Ping(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Res, error)
	GetClaims(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Claim], error)
	GetSPIs(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SPI], error)
	GetNDCs(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[NDC], error)
	GetEntities(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Entity], error)
	GetPharmacies(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Pharmacy], error)
	GetESP1Pharms(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ESP1PharmNDC], error)
	GetEligibilityLedger(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Eligibility], error)
	GetAuths(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Auth], error)
	GetDesignations(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Designation], error)
	GetLDNs(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LDN], error)
	SyncCommands(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[Command, Res], error)
	SyncScrubs(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[Scrub, Res], error)
	SyncMetrics(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[Metrics, Res], error)
	SyncScrubRebates(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ScrubRebate, Res], error)
	SyncScrubClaims(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ScrubClaim, Res], error)
	SyncScrubMatches(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ScrubMatch, Res], error)
	SyncScrubAttempts(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ScrubAttempt, Res], error)
}

type titanClient struct {
	cc grpc.ClientConnInterface
}

func NewTitanClient(cc grpc.ClientConnInterface) TitanClient {
	return &titanClient{cc}
}

func (c *titanClient) Ping(ctx context.Context, in *Req, opts ...grpc.CallOption) (*Res, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Res)
	err := c.cc.Invoke(ctx, Titan_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *titanClient) GetClaims(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Claim], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[0], Titan_GetClaims_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncReq, Claim]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetClaimsClient = grpc.ServerStreamingClient[Claim]

func (c *titanClient) GetSPIs(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SPI], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[1], Titan_GetSPIs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncReq, SPI]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetSPIsClient = grpc.ServerStreamingClient[SPI]

func (c *titanClient) GetNDCs(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[NDC], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[2], Titan_GetNDCs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncReq, NDC]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetNDCsClient = grpc.ServerStreamingClient[NDC]

func (c *titanClient) GetEntities(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Entity], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[3], Titan_GetEntities_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncReq, Entity]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetEntitiesClient = grpc.ServerStreamingClient[Entity]

func (c *titanClient) GetPharmacies(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Pharmacy], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[4], Titan_GetPharmacies_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncReq, Pharmacy]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetPharmaciesClient = grpc.ServerStreamingClient[Pharmacy]

func (c *titanClient) GetESP1Pharms(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ESP1PharmNDC], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[5], Titan_GetESP1Pharms_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncReq, ESP1PharmNDC]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetESP1PharmsClient = grpc.ServerStreamingClient[ESP1PharmNDC]

func (c *titanClient) GetEligibilityLedger(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Eligibility], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[6], Titan_GetEligibilityLedger_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncReq, Eligibility]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetEligibilityLedgerClient = grpc.ServerStreamingClient[Eligibility]

func (c *titanClient) GetAuths(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Auth], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[7], Titan_GetAuths_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncReq, Auth]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetAuthsClient = grpc.ServerStreamingClient[Auth]

func (c *titanClient) GetDesignations(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Designation], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[8], Titan_GetDesignations_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncReq, Designation]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetDesignationsClient = grpc.ServerStreamingClient[Designation]

func (c *titanClient) GetLDNs(ctx context.Context, in *SyncReq, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LDN], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[9], Titan_GetLDNs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SyncReq, LDN]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetLDNsClient = grpc.ServerStreamingClient[LDN]

func (c *titanClient) SyncCommands(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[Command, Res], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[10], Titan_SyncCommands_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Command, Res]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncCommandsClient = grpc.ClientStreamingClient[Command, Res]

func (c *titanClient) SyncScrubs(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[Scrub, Res], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[11], Titan_SyncScrubs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Scrub, Res]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncScrubsClient = grpc.ClientStreamingClient[Scrub, Res]

func (c *titanClient) SyncMetrics(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[Metrics, Res], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[12], Titan_SyncMetrics_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Metrics, Res]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncMetricsClient = grpc.ClientStreamingClient[Metrics, Res]

func (c *titanClient) SyncScrubRebates(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ScrubRebate, Res], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[13], Titan_SyncScrubRebates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ScrubRebate, Res]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncScrubRebatesClient = grpc.ClientStreamingClient[ScrubRebate, Res]

func (c *titanClient) SyncScrubClaims(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ScrubClaim, Res], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[14], Titan_SyncScrubClaims_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ScrubClaim, Res]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncScrubClaimsClient = grpc.ClientStreamingClient[ScrubClaim, Res]

func (c *titanClient) SyncScrubMatches(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ScrubMatch, Res], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[15], Titan_SyncScrubMatches_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ScrubMatch, Res]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncScrubMatchesClient = grpc.ClientStreamingClient[ScrubMatch, Res]

func (c *titanClient) SyncScrubAttempts(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ScrubAttempt, Res], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Titan_ServiceDesc.Streams[16], Titan_SyncScrubAttempts_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ScrubAttempt, Res]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncScrubAttemptsClient = grpc.ClientStreamingClient[ScrubAttempt, Res]

// TitanServer is the server API for Titan service.
// All implementations must embed UnimplementedTitanServer
// for forward compatibility.
type TitanServer interface {
	Ping(context.Context, *Req) (*Res, error)
	GetClaims(*SyncReq, grpc.ServerStreamingServer[Claim]) error
	GetSPIs(*SyncReq, grpc.ServerStreamingServer[SPI]) error
	GetNDCs(*SyncReq, grpc.ServerStreamingServer[NDC]) error
	GetEntities(*SyncReq, grpc.ServerStreamingServer[Entity]) error
	GetPharmacies(*SyncReq, grpc.ServerStreamingServer[Pharmacy]) error
	GetESP1Pharms(*SyncReq, grpc.ServerStreamingServer[ESP1PharmNDC]) error
	GetEligibilityLedger(*SyncReq, grpc.ServerStreamingServer[Eligibility]) error
	GetAuths(*SyncReq, grpc.ServerStreamingServer[Auth]) error
	GetDesignations(*SyncReq, grpc.ServerStreamingServer[Designation]) error
	GetLDNs(*SyncReq, grpc.ServerStreamingServer[LDN]) error
	SyncCommands(grpc.ClientStreamingServer[Command, Res]) error
	SyncScrubs(grpc.ClientStreamingServer[Scrub, Res]) error
	SyncMetrics(grpc.ClientStreamingServer[Metrics, Res]) error
	SyncScrubRebates(grpc.ClientStreamingServer[ScrubRebate, Res]) error
	SyncScrubClaims(grpc.ClientStreamingServer[ScrubClaim, Res]) error
	SyncScrubMatches(grpc.ClientStreamingServer[ScrubMatch, Res]) error
	SyncScrubAttempts(grpc.ClientStreamingServer[ScrubAttempt, Res]) error
	mustEmbedUnimplementedTitanServer()
}

// UnimplementedTitanServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTitanServer struct{}

func (UnimplementedTitanServer) Ping(context.Context, *Req) (*Res, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedTitanServer) GetClaims(*SyncReq, grpc.ServerStreamingServer[Claim]) error {
	return status.Errorf(codes.Unimplemented, "method GetClaims not implemented")
}
func (UnimplementedTitanServer) GetSPIs(*SyncReq, grpc.ServerStreamingServer[SPI]) error {
	return status.Errorf(codes.Unimplemented, "method GetSPIs not implemented")
}
func (UnimplementedTitanServer) GetNDCs(*SyncReq, grpc.ServerStreamingServer[NDC]) error {
	return status.Errorf(codes.Unimplemented, "method GetNDCs not implemented")
}
func (UnimplementedTitanServer) GetEntities(*SyncReq, grpc.ServerStreamingServer[Entity]) error {
	return status.Errorf(codes.Unimplemented, "method GetEntities not implemented")
}
func (UnimplementedTitanServer) GetPharmacies(*SyncReq, grpc.ServerStreamingServer[Pharmacy]) error {
	return status.Errorf(codes.Unimplemented, "method GetPharmacies not implemented")
}
func (UnimplementedTitanServer) GetESP1Pharms(*SyncReq, grpc.ServerStreamingServer[ESP1PharmNDC]) error {
	return status.Errorf(codes.Unimplemented, "method GetESP1Pharms not implemented")
}
func (UnimplementedTitanServer) GetEligibilityLedger(*SyncReq, grpc.ServerStreamingServer[Eligibility]) error {
	return status.Errorf(codes.Unimplemented, "method GetEligibilityLedger not implemented")
}
func (UnimplementedTitanServer) GetAuths(*SyncReq, grpc.ServerStreamingServer[Auth]) error {
	return status.Errorf(codes.Unimplemented, "method GetAuths not implemented")
}
func (UnimplementedTitanServer) GetDesignations(*SyncReq, grpc.ServerStreamingServer[Designation]) error {
	return status.Errorf(codes.Unimplemented, "method GetDesignations not implemented")
}
func (UnimplementedTitanServer) GetLDNs(*SyncReq, grpc.ServerStreamingServer[LDN]) error {
	return status.Errorf(codes.Unimplemented, "method GetLDNs not implemented")
}
func (UnimplementedTitanServer) SyncCommands(grpc.ClientStreamingServer[Command, Res]) error {
	return status.Errorf(codes.Unimplemented, "method SyncCommands not implemented")
}
func (UnimplementedTitanServer) SyncScrubs(grpc.ClientStreamingServer[Scrub, Res]) error {
	return status.Errorf(codes.Unimplemented, "method SyncScrubs not implemented")
}
func (UnimplementedTitanServer) SyncMetrics(grpc.ClientStreamingServer[Metrics, Res]) error {
	return status.Errorf(codes.Unimplemented, "method SyncMetrics not implemented")
}
func (UnimplementedTitanServer) SyncScrubRebates(grpc.ClientStreamingServer[ScrubRebate, Res]) error {
	return status.Errorf(codes.Unimplemented, "method SyncScrubRebates not implemented")
}
func (UnimplementedTitanServer) SyncScrubClaims(grpc.ClientStreamingServer[ScrubClaim, Res]) error {
	return status.Errorf(codes.Unimplemented, "method SyncScrubClaims not implemented")
}
func (UnimplementedTitanServer) SyncScrubMatches(grpc.ClientStreamingServer[ScrubMatch, Res]) error {
	return status.Errorf(codes.Unimplemented, "method SyncScrubMatches not implemented")
}
func (UnimplementedTitanServer) SyncScrubAttempts(grpc.ClientStreamingServer[ScrubAttempt, Res]) error {
	return status.Errorf(codes.Unimplemented, "method SyncScrubAttempts not implemented")
}
func (UnimplementedTitanServer) mustEmbedUnimplementedTitanServer() {}
func (UnimplementedTitanServer) testEmbeddedByValue()               {}

// UnsafeTitanServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TitanServer will
// result in compilation errors.
type UnsafeTitanServer interface {
	mustEmbedUnimplementedTitanServer()
}

func RegisterTitanServer(s grpc.ServiceRegistrar, srv TitanServer) {
	// If the following call pancis, it indicates UnimplementedTitanServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Titan_ServiceDesc, srv)
}

func _Titan_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TitanServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Titan_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TitanServer).Ping(ctx, req.(*Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _Titan_GetClaims_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SyncReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TitanServer).GetClaims(m, &grpc.GenericServerStream[SyncReq, Claim]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetClaimsServer = grpc.ServerStreamingServer[Claim]

func _Titan_GetSPIs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SyncReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TitanServer).GetSPIs(m, &grpc.GenericServerStream[SyncReq, SPI]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetSPIsServer = grpc.ServerStreamingServer[SPI]

func _Titan_GetNDCs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SyncReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TitanServer).GetNDCs(m, &grpc.GenericServerStream[SyncReq, NDC]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetNDCsServer = grpc.ServerStreamingServer[NDC]

func _Titan_GetEntities_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SyncReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TitanServer).GetEntities(m, &grpc.GenericServerStream[SyncReq, Entity]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetEntitiesServer = grpc.ServerStreamingServer[Entity]

func _Titan_GetPharmacies_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SyncReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TitanServer).GetPharmacies(m, &grpc.GenericServerStream[SyncReq, Pharmacy]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetPharmaciesServer = grpc.ServerStreamingServer[Pharmacy]

func _Titan_GetESP1Pharms_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SyncReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TitanServer).GetESP1Pharms(m, &grpc.GenericServerStream[SyncReq, ESP1PharmNDC]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetESP1PharmsServer = grpc.ServerStreamingServer[ESP1PharmNDC]

func _Titan_GetEligibilityLedger_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SyncReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TitanServer).GetEligibilityLedger(m, &grpc.GenericServerStream[SyncReq, Eligibility]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetEligibilityLedgerServer = grpc.ServerStreamingServer[Eligibility]

func _Titan_GetAuths_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SyncReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TitanServer).GetAuths(m, &grpc.GenericServerStream[SyncReq, Auth]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetAuthsServer = grpc.ServerStreamingServer[Auth]

func _Titan_GetDesignations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SyncReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TitanServer).GetDesignations(m, &grpc.GenericServerStream[SyncReq, Designation]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetDesignationsServer = grpc.ServerStreamingServer[Designation]

func _Titan_GetLDNs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SyncReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TitanServer).GetLDNs(m, &grpc.GenericServerStream[SyncReq, LDN]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_GetLDNsServer = grpc.ServerStreamingServer[LDN]

func _Titan_SyncCommands_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TitanServer).SyncCommands(&grpc.GenericServerStream[Command, Res]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncCommandsServer = grpc.ClientStreamingServer[Command, Res]

func _Titan_SyncScrubs_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TitanServer).SyncScrubs(&grpc.GenericServerStream[Scrub, Res]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncScrubsServer = grpc.ClientStreamingServer[Scrub, Res]

func _Titan_SyncMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TitanServer).SyncMetrics(&grpc.GenericServerStream[Metrics, Res]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncMetricsServer = grpc.ClientStreamingServer[Metrics, Res]

func _Titan_SyncScrubRebates_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TitanServer).SyncScrubRebates(&grpc.GenericServerStream[ScrubRebate, Res]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncScrubRebatesServer = grpc.ClientStreamingServer[ScrubRebate, Res]

func _Titan_SyncScrubClaims_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TitanServer).SyncScrubClaims(&grpc.GenericServerStream[ScrubClaim, Res]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncScrubClaimsServer = grpc.ClientStreamingServer[ScrubClaim, Res]

func _Titan_SyncScrubMatches_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TitanServer).SyncScrubMatches(&grpc.GenericServerStream[ScrubMatch, Res]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncScrubMatchesServer = grpc.ClientStreamingServer[ScrubMatch, Res]

func _Titan_SyncScrubAttempts_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TitanServer).SyncScrubAttempts(&grpc.GenericServerStream[ScrubAttempt, Res]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Titan_SyncScrubAttemptsServer = grpc.ClientStreamingServer[ScrubAttempt, Res]

// Titan_ServiceDesc is the grpc.ServiceDesc for Titan service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Titan_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "main.Titan",
	HandlerType: (*TitanServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Titan_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetClaims",
			Handler:       _Titan_GetClaims_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetSPIs",
			Handler:       _Titan_GetSPIs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetNDCs",
			Handler:       _Titan_GetNDCs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetEntities",
			Handler:       _Titan_GetEntities_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetPharmacies",
			Handler:       _Titan_GetPharmacies_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetESP1Pharms",
			Handler:       _Titan_GetESP1Pharms_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetEligibilityLedger",
			Handler:       _Titan_GetEligibilityLedger_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetAuths",
			Handler:       _Titan_GetAuths_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetDesignations",
			Handler:       _Titan_GetDesignations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetLDNs",
			Handler:       _Titan_GetLDNs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SyncCommands",
			Handler:       _Titan_SyncCommands_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SyncScrubs",
			Handler:       _Titan_SyncScrubs_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SyncMetrics",
			Handler:       _Titan_SyncMetrics_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SyncScrubRebates",
			Handler:       _Titan_SyncScrubRebates_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SyncScrubClaims",
			Handler:       _Titan_SyncScrubClaims_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SyncScrubMatches",
			Handler:       _Titan_SyncScrubMatches_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SyncScrubAttempts",
			Handler:       _Titan_SyncScrubAttempts_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "grpc.proto",
}
